<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scalability</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../../common/styles.css" rel="stylesheet">
    <script>
        // Function to include an external HTML file
        function loadHTML(file, elementId) {
            fetch(file)
                .then(response => response.text())
                .then(data => document.getElementById(elementId).innerHTML = data)
                .catch(error => console.error('Error loading HTML:', error));
        }
    </script>
</head>

<body onload="loadHTML('../../common/navbar.html', 'navbar-placeholder')">
    <!-- Navbar Placeholder -->
    <div id="navbar-placeholder"></div>

    <div class="container">

        <div class="content">
            <h3 class="section-title">What is scalability?</h3>
            <p>Scalability ensures that an application or service can continue to perform efficiently as the number of users or the volume of data increases. 
                Essentially, it’s about making sure a system can expand and manage increasing demands effectively, without compromising performance or efficiency.
            </p>
                The workload can be of different types, including the following:
                <ul>
                    <li><strong>Request workload:</strong> This is the number of requests served by the system.</li>
                    <li><strong>Data/storage workload:</strong> This is the amount of data stored by the system.</li>
                </ul>
            </p>
            <br>
            <h3 class="section-title">How Scalability Works?</h3>
            <p>As a system scales, it must be able to maintain performance, availability, and reliability, even when subjected to higher loads.</p> 
                This involves the following key concepts:
                <ul>
                    <li><strong>Resource Utilization:</strong> Efficient use of CPU, memory, disk I/O, and network resources to ensure that the system can handle additional workloads without degradation in performance.</li>
                    <li><strong>Load Balancing:</strong> Distributing the workload across multiple servers or instances to avoid overloading a single resource.</li>
                    <li><strong>Redundancy:</strong> Creating backups or duplicate resources to ensure availability in case of failure.</li>
                </ul>
                <br>
            <h3 class="section-title">Types of Scalability</h3>
            <p>There are several types of scalability:</p>
            <ul>
                <li><strong>Vertical scalability(scaling up):</strong> This means adding more power to your existing machines by upgrading server with more RAM, faster CPUs, or additional storage.</li>
                    <ul>
                        <strong>Example:</strong> Moving from a 4-core CPU to an 8-core CPU on the same server.
                        <li><strong>Pros:</strong> Simpler to implement, as it doesn't require changes to the software architecture.</li>
                        <li><strong>Cons:</strong> Limited by the maximum capacity of the machine; higher risk of a single point of failure.</li>
                    </ul>
                    <img src="../../images/vertical-scale-up.PNG" alt="Vertical Scaling Diagram">
                <li><strong>Horizontal scalability(scaling out):</strong> Adding more machines or nodes to distribute the load across multiple systems.
                    <ul> 
                    <Strong>Example:</Strong> Adding more servers to a web application cluster to handle increased traffic.
                    <li><Strong>Pros:</Strong> Provides more flexibility and fault tolerance; can scale indefinitely by adding more machines.</li>
                    <li><Strong>Cons:</Strong> More complex to implement, requiring distributed systems techniques like load balancing, data partitioning, and consistency management.</li>
                    <img src="../../images/horizontal-scale-out.PNG" alt="Horizontal Scaling Diagram">
                </ul>
                    <li><strong>Diagonal Scalability:</strong> A combination of both vertical and horizontal scaling to optimize resources and performance.</li>
                    <ul>
                        <li><Strong>Example:</Strong> First upgrading the resources of a single server and, when limits are reached, adding additional servers.</li>
                        <li><Strong>Pros:</Strong> Combines the benefits of both vertical and horizontal scaling, allowing for a balanced approach.</li>
                    </ul>
            </ul>
            <br>

            <h3 class="section-title">Where is Scalability Used?</h2>
            <p>Scalability is critical in various domains such as:</p>
            <ul>
                <li><strong>Web Applications: </strong>Handling increased traffic, especially during peak times like sales or events.</li>
                <li><strong>Cloud Computing: </strong>Automatically scaling resources based on demand in a pay-as-you-go model.</li>
                <li><strong>Databases: </strong>Managing large volumes of data with high read/write demands.</li>
                <li><strong>Search Engines: </strong>Managing and indexing vast amounts of data while serving millions of user queries.</li>
                <li><strong>Microservices: </strong>Scaling individual components of an application independently.</li>
            </ul>
            <br>
            <h2 class="section-title">Technology Involved in Scalability</h2>
            <p>Several technologies and strategies are used to achieve scalability:</p>
            <ol>
                <li><strong>Load Balancers:</strong> Distribute incoming traffic across multiple servers.<br>
                    <strong>Role:</strong> Distribute incoming traffic across multiple servers, ensuring no single server becomes overwhelmed.</br>
                    <strong>Examples:</strong> Nginx, HAProxy, AWS Elastic Load Balancer.</br>
                </li><br>
                <li><strong>Microservices Architecture:</strong> Decomposes applications into smaller, independent services.<br>
                    <strong>Role:</strong> Breaks down applications into smaller, independent services that can be scaled independently based on demand.</br>
                    <strong>Examples:</strong> Netflix's microservices architecture.</br>
                </li><br>
                <li><strong>Containerization:</strong> Tools like Docker and Kubernetes help manage and scale containers.<br>
                    <strong>Role:</strong> Containerization allows applications to run consistently across different environments, and orchestration tools manage the deployment, scaling, and operations of containers.<br>
                    <strong>Examples:</strong> Docker for containerization, Kubernetes for orchestration.<br>
                </li><br>
                <li><strong>Database Sharding:</strong> Splitting a database into smaller, more manageable pieces.<br>
                    <strong>Role: </strong>Splitting a database into smaller, more manageable pieces (shards) to spread the load.<br>
                    <strong>Examples: </strong>MongoDB sharding, MySQL partitioning.<br>
                </li>
            </ol>
            
            <br>
            <h3 class="section-title">Interview Questions and Answers</h2>

            <div class="interview-question">
                <strong>Q1: What is scalability, and why is it important?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>Answer:</strong> Scalability is the ability of a system to handle increasing workloads or its capacity to be enlarged to accommodate that growth. It’s crucial for ensuring that systems can continue to perform well under increased demand, making them more resilient and capable of supporting business growth.</p>
            </div>

            <div class="interview-question">
                <strong>Q2: What’s the difference between vertical and horizontal scaling?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>Answer:</strong> Vertical scaling (scaling up) involves adding more resources to a single machine, such as more CPU or RAM. Horizontal scaling (scaling out) involves adding more machines or nodes to distribute the workload. Vertical scaling is easier to implement but has limits, whereas horizontal scaling can provide more flexibility and fault tolerance.</p>
            </div>

            <div class="interview-question">
                <strong>Q3: How do load balancers contribute to scalability?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>Answer:</strong> Load balancers distribute incoming network traffic across multiple servers, ensuring no single server becomes overwhelmed. This helps in scaling applications by balancing the load and improving availability and reliability.</p>
            </div>

            <div class="interview-question">
                <strong>Q4: What challenges might you face when scaling a system horizontally?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>Answer:</strong> Horizontal scaling introduces challenges like managing data consistency, network latency, load balancing, and ensuring all nodes are synchronized. It can also complicate the architecture and require robust monitoring and orchestration tools.</p>
            </div>

            <div class="interview-question">
                <strong>Q5: How would you scale a monolithic application to handle increased load?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>What they're asking:</strong> The interviewer wants to assess your understanding of the challenges associated with monolithic architectures and your approach to transitioning to a more scalable architecture.</p>
                    <p><strong>Answer:</strong>
                    <ul>
                        <li>Start by identifying the bottlenecks in the application (e.g., database, CPU, memory).</li>
                        <li>Use vertical scaling (adding more resources to the existing server) as a short-term solution.</li>
                        <li>For long-term scalability, consider breaking the monolith into microservices.</li>
                        <li>Use load balancers to distribute traffic and consider database sharding or replication.</li>
                        <li>Implement caching strategies to reduce database load.</li>
                        <li>Discuss the importance of using CI/CD pipelines to manage and deploy changes efficiently.</li>
                    </ul>
                    </p>
            </div>
            <div class="interview-question">
                <strong>Q6: How would you ensure data consistency in a distributed system while scaling?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>What they're asking:</strong> The interviewer wants to see how you balance the trade-offs between consistency, availability, and partition tolerance (CAP theorem) in a distributed environment.</p>
                    <p><strong>Answer:</strong>
                    <ul>
                        <li>Describe the challenges of maintaining consistency across distributed systems.</li>
                        <li>Discuss approaches like eventual consistency, where the system allows temporary inconsistencies that will be resolved over time.</li>
                        <li>Explain techniques like distributed transactions, two-phase commit (2PC), or distributed consensus algorithms (e.g., Paxos, Raft).</li>
                        <li>Mention the use of database replication strategies, such as master-slave or multi-master replication, to maintain consistency.</li>
                        <li>Discuss how different systems (e.g., NoSQL vs. SQL) handle consistency and the trade-offs involved.</li>
                    </ul>
                    </p>
            </div>
            <div class="interview-question">
                <strong>Q7: How would you scale a database in a system with millions of users?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>What they're asking:</strong> The interviewer wants to see your approach to database scalability, including strategies for handling large volumes of data and high transaction rates.</p>
                    <p><strong>Answer:</strong>
                    <ul>
                        <li>Start by optimizing database queries and indexing to improve performance.</li>
                        <li>Implement read replicas to distribute read queries across multiple databases.</li>
                        <li>Use database sharding to horizontally partition the database, distributing data across multiple servers based on a shard key.</li>
                        <li>Consider caching frequently accessed data using in-memory stores like Redis or Memcached.</li>
                        <li>Discuss the use of NoSQL databases for highly scalable systems, especially for unstructured or semi-structured data.</li>
                        <li>Mention the importance of data partitioning strategies (e.g., range-based, hash-based) in sharding to ensure even distribution of data.</li>
                    </ul>
                    </p>
            </div>
            <div class="interview-question">
                <strong>Q8: How do you handle session management in a scalable web application?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>What they're asking: </strong>The interviewer is probing your understanding of state management in distributed systems and scalable web architectures. </p>
                    <p><strong>Answer:</strong>
                    <ul>
                        <li>Explain the problem of managing state in a stateless web application.</li>
                        <li>Use sticky sessions to keep a user’s session on the same server, though it’s not always the best for scalability</li>
                        <li>Discuss using a distributed session store (e.g., Redis, Memcached) to store session data, which allows any server in a cluster to access the session.</li>
                        <li>Mention JWT (JSON Web Tokens) for stateless authentication, which doesn’t require server-side session storage.</li>
                        <li>Address considerations like session replication in a clustered environment to ensure availability and consistency.</li>
                    </ul>
                    </p>
            </div>
            <div class="interview-question">
                <strong>Q9: How would you design a globally distributed system that needs to handle both high availability and low latency?</strong>
            </div>
            <div class="interview-answer">
                <p><strong>What they're asking: </strong>This question tests your ability to design a system that meets both availability and performance requirements on a global scale. </p>
                    <p><strong>Answer:</strong>
                    <ul>
                        <li>Use CDNs (Content Delivery Networks) to cache and serve static content closer to users.</li>
                        <li>Deploy your application in multiple geographic regions using cloud providers like AWS, Azure, or Google Cloud.</li>
                        <li>Implement global load balancing to route users to the nearest data center, reducing latency.</li>
                        <li>Use data replication across regions to ensure data availability, considering eventual consistency if needed.</li>
                        <li>Discuss the use of geo-partitioning to store data locally within regions to meet data residency requirements.</li>
                        <li>Mention monitoring and failover strategies to detect and recover from regional outages quickly.</li>
                    </ul>
                    </p>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="footer">
        <p>&copy; 2024 My Blog. All rights reserved.</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>